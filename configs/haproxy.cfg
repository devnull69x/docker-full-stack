global
    log     127.0.0.1 local0 alert
    log     127.0.0.1 local1 notice debug
    maxconn 4096

    #ssl-default-bind-options   no-sslv3 no-tls-tickets force-tlsv12
    #ssl-default-bind-ciphers   ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS

    spread-checks   4
    tune.maxrewrite 1024
    tune.ssl.default-dh-param 2048

defaults
    log     global
    balance roundrobin
    option  httplog
    option  dontlognull
    option  persist
    option  http-server-close
    option  redispatch
    option  forwardfor except 127.0.0.0/8
    retries 3
    timeout http-request 20s
    timeout queue 1m
    timeout connect 10s
    timeout client 50s
    timeout server 50s
    timeout http-keep-alive 30s
    timeout check 6s
    maxconn 3000

    errorfile 400 /etc/haproxy/errors/400.http
    errorfile 403 /etc/haproxy/errors/403.http
    errorfile 408 /etc/haproxy/errors/408.http
    errorfile 500 /etc/haproxy/errors/500.http
    errorfile 502 /etc/haproxy/errors/502.http
    errorfile 503 /etc/haproxy/errors/503.http
    errorfile 504 /etc/haproxy/errors/504.http

frontend fe_http
option forwardfor except 127.0.0.1
option httpclose
bind *:8080
default_backend be_http

backend be_http
balance roundrobin
server nginx service:8080 check port 8080

# Define your hostnames
#acl wordpress_domain_1 hdr(host) -i wp1-docker.ddns.net
#acl wordpress_domain_2 hdr(host) -i wp2-docker.ddns.net
#acl wordpress_domain_3 hdr(host) -i wp3-docker.ddns.net

## figure out backend to use based on domainname
#use_backend wordpress1 if wordpress_domain_1 # your first registered hostname
#use_backend wordpress2 if wordpress_domain_2 # your second registered hostname
#use_backend wordpress3 if wordpress_domain_3 # your third registered hostname

#backend wordpress1 # wp1-docker.ddns.net container
#balance roundrobin
#option httpclose
#option forwardfor
#server s1 172.17.0.6:80 # This ip should be the ip of the wordpress container 1

#backend wordpress2 # wp2-docker.ddns.net container
#balance roundrobin
#option httpclose
#option forwardfor
#server s2 172.17.0.7:80 # This ip should be the ip of the wordpress container 2

#listen haproxy-stats
#bind  *:1936
#mode  http
#stats enable
#stats hide-version
#stats refresh 5s
#stats uri     /haproxy?stats
#stats realm   Haproxy\ Statistics
#stats auth    haproxy:haproxy
#
#listen rabbitmq
#bind    *:5672
#mode    tcp
#option  tcplog
#balance roundrobin
#server  rabbitmq-node-1 rabbitmq-node-1:5672 check inter 5000 rise 3 fall 5
#server  rabbitmq-node-2 rabbitmq-node-2:5672 check inter 5000 rise 3 fall 5
#server  rabbitmq-node-3 rabbitmq-node-3:5672 check inter 5000 rise 3 fall 5
## Create custom headers as temporary holding places for info
#http-request set-header X-Scheme http if !{ ssl_fc }
#http-request set-header X-Scheme https if { ssl_fc }
#http-request set-header X-TraceId %[rand,hex,bytes(8,8),lower]%[rand,hex,bytes(8,8),lower]%[rand,hex,bytes(8,8),lower]
#http-request set-header X-SegmentId0 %[rand,hex,bytes(8,8),lower]%[rand,hex,bytes(8,8),lower]
#http-request set-header X-SegmentId1 %[rand,hex,bytes(8,8),lower]%[rand,hex,bytes(8,8),lower]
#http-request set-header X-SegmentId2 %[rand,hex,bytes(8,8),lower]%[rand,hex,bytes(8,8),lower]
#http-request set-header X-SegmentId3 %[rand,hex,bytes(8,8),lower]%[rand,hex,bytes(8,8),lower]
#http-request set-header X-SegmentId4 %[rand,hex,bytes(8,8),lower]%[rand,hex,bytes(8,8),lower]
 # Declare capture slots for logging headers
    #declare capture request len 512
    #http-request capture req.fhdr(User-Agent) id 0
    #
    #declare capture request len 5
    #http-request capture req.hdr(X-Scheme) id 1
    #
    #declare capture request len 512
    #http-request capture req.hdr(Host) id 2
    #
    #declare capture request len 24
    #http-request capture req.hdr(X-TraceId) id 3
    #
    #declare capture request len 16
    #http-request capture req.hdr(X-SegmentId0) id 4
    #
    #declare capture request len 16
    #http-request capture req.hdr(X-SegmentId1) id 5
    #
    #declare capture request len 16
    #http-request capture req.hdr(X-SegmentId2) id 6
    #
    #declare capture request len 16
    #http-request capture req.hdr(X-SegmentId3) id 7
    #
    #declare capture request len 16
    #http-request capture req.hdr(X-SegmentId4) id 8
    #
    #declare capture response len 8
    #http-response capture res.hdr(Content-Length) id 0
    #
    ## Generate a unique Trace ID
    #unique-id-format %{+X}o\ 1-%[date,hex,bytes(8,8),lower]-%[capture.req.hdr(3)]
    #http-request set-header X-Amzn-Trace-Id Root=%[unique-id,lower]

    # ci = client IP
    # cp = client port
    # Ts = timestamp
    # ft = frontend name
    # b = backend name
    # s = server name
    # TR = time to receive 1st byte
    # Tw = time spent waiting in queue
    # Tc = time spent to establish server connection
    # Tr = server response time
    # Ta = total active time of request
    # ST = status code
    # B = bytes read
    # CC = captured request cookie
    # CS = captured response cookie
    # ts = termination state code
    # ac = active connections
    # fc = frontend connections
    # bc = backend connections
    # sc = server connections
    # rc = number of retries
    # sq = connections queued for server
    # bq = requests processed before this one
    # capture.req.method = HTTP method
    # capture.req.hdr(0) = User-Agent
    # scheme://URL
    # trace ID
    # segment ID 1
    # segment ID 2
    # segment ID 3
    # segment ID 4
    # segment ID 5
    # capture.res.hdr(0) = Content-Length

    #log-format "%ci|%cp|%Ts|%ft|%b|%s|%TR|%Tw|%Tc|%Tr|%Ta|%ST|%B|%CC|%CS|%ts|%ac|%fc|%bc|%sc|%rc|%sq|%bq|%[capture.req.method]|%[capture.req.hdr(0)]|%[capture.req.hdr(1)]://%[capture.req.hdr(2)]%HP|%ID|%[capture.req.hdr(4)]|%[capture.req.hdr(5)]|%[capture.req.hdr(6)]|%[capture.req.hdr(7)]|%[capture.req.hdr(8)]|%[capture.res.hdr(0)]"
    #
    #default_backend be_servers
    #
#frontend stats
    #bind *:8404
    #stats enable
    #stats uri /
    #stats refresh 10s
    #
#backend be_servers
    #server s1 server:80 check


#frontend fe
#
#    bind *:80
#
#    acl a path_beg -i /a
#    use_backend a if a
#
#    acl b path_beg -i /b
#    use_backend b if b
#
#backend a
#
#    http-request replace-path ^/a[/]?(.*) /\1
#    server 1 service_a:80 inter 1000 check
#
#backend b
#
#    http-request replace-path ^/b[/]?(.*) /\1
#    server 1 service_b:80 inter 1000 check